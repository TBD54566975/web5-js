## API Report File for "@web5/common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import type { AbstractLevel } from 'abstract-level';
import type { Duplex } from 'readable-stream';
import type { Multibase } from 'multiformats';
import { Readable } from 'readable-stream';
import type { ReadableStateOptions } from 'readable-stream';
import type { Transform } from 'readable-stream';
import { default as TtlCache } from '@isaacs/ttlcache';
import type { Writable } from 'readable-stream';

// @public (undocumented)
export class Convert {
    constructor(data: any, format: string);
    // (undocumented)
    static arrayBuffer(data: ArrayBuffer): Convert;
    // (undocumented)
    static asyncIterable(data: AsyncIterable<any>): Convert;
    // (undocumented)
    static base32Z(data: string): Convert;
    // (undocumented)
    static base58Btc(data: string): Convert;
    // (undocumented)
    static base64Url(data: string): Convert;
    static bufferSource(data: BufferSource): Convert;
    // (undocumented)
    data: any;
    // (undocumented)
    format: string;
    // (undocumented)
    static hex(data: string): Convert;
    // (undocumented)
    static multibase(data: string): Convert;
    // (undocumented)
    static object(data: Record<string, any>): Convert;
    // (undocumented)
    static string(data: string): Convert;
    // (undocumented)
    toArrayBuffer(): ArrayBuffer;
    // (undocumented)
    toArrayBufferAsync(): Promise<ArrayBuffer>;
    // (undocumented)
    toBase32Z(): string;
    // (undocumented)
    toBase58Btc(): string;
    // (undocumented)
    toBase64Url(): string;
    // (undocumented)
    toBlobAsync(): Promise<Blob>;
    // (undocumented)
    toHex(): string;
    // (undocumented)
    toMultibase(): Multibase<any>;
    // (undocumented)
    toObject(): object;
    // (undocumented)
    toObjectAsync(): Promise<any>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    toStringAsync(): Promise<string>;
    // (undocumented)
    toUint8Array(): Uint8Array;
    // (undocumented)
    toUint8ArrayAsync(): Promise<Uint8Array>;
    // (undocumented)
    static uint8Array(data: Uint8Array): Convert;
}

// Warning: (ae-forgotten-export) The symbol "ArrayLengthMutationKeys" needs to be exported by the entry point index.d.ts
//
// @public
export type FixedLengthArray<T extends any[]> = Pick<T, Exclude<keyof T, ArrayLengthMutationKeys>> & {
    [Symbol.iterator]: () => IterableIterator<ArrayItems<T>>;
};

// @public
export function isArrayBufferSlice(arrayBufferView: ArrayBufferView): boolean;

// @public
export function isAsyncIterable(obj: any): obj is AsyncIterable<any>;

// @public
export function isDefined<T>(arg: T): arg is Exclude<T, null | undefined>;

// @public
export function isEmptyObject(obj: unknown): boolean;

// @public
export interface KeyValueStore<K, V> {
    clear(): Promise<void>;
    close(): Promise<void>;
    delete(key: K): Promise<boolean | void>;
    get(key: K): Promise<V | undefined>;
    set(key: K, value: V): Promise<void>;
}

// @public (undocumented)
export class LevelStore<K = string, V = any> implements KeyValueStore<K, V> {
    constructor({ db, location }?: {
        db?: AbstractLevel<string | Buffer | Uint8Array, K, V>;
        location?: string;
    });
    // (undocumented)
    clear(): Promise<void>;
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    delete(key: K): Promise<void>;
    // (undocumented)
    get(key: K): Promise<V | undefined>;
    // (undocumented)
    set(key: K, value: V): Promise<void>;
}

// @public
export class MemoryStore<K, V> implements KeyValueStore<K, V> {
    clear(): Promise<void>;
    close(): Promise<void>;
    delete(id: K): Promise<boolean>;
    get(id: K): Promise<V | undefined>;
    has(id: K): Promise<boolean>;
    list(): Promise<V[]>;
    set(id: K, key: V): Promise<void>;
}

// @public
export class Multicodec {
    static addPrefix(options: {
        code?: MulticodecCode;
        data: Uint8Array;
        name?: string;
    }): Uint8Array;
    static codeToName: Map<number, string>;
    static getCodeFromData(options: {
        prefixedData: Uint8Array;
    }): MulticodecCode;
    static getCodeFromName(options: {
        name: string;
    }): MulticodecCode;
    static getNameFromCode(options: {
        code: MulticodecCode;
    }): string;
    static nameToCode: Map<string, number>;
    static registerCodec(codec: MulticodecDefinition<MulticodecCode>): void;
    static removePrefix(options: {
        prefixedData: Uint8Array;
    }): {
        code: MulticodecCode;
        name: string;
        data: Uint8Array;
    };
}

// @public (undocumented)
export type MulticodecCode = number;

// @public (undocumented)
export type MulticodecDefinition<MulticodecCode> = {
    code: MulticodecCode;
    name: string;
};

// @public (undocumented)
export class NodeStream {
    static consumeToArrayBuffer({ readable }: {
        readable: Readable;
    }): Promise<ArrayBuffer>;
    static consumeToBlob({ readable }: {
        readable: Readable;
    }): Promise<Blob>;
    static consumeToBytes({ readable }: {
        readable: Readable;
    }): Promise<Uint8Array>;
    static consumeToJson({ readable }: {
        readable: Readable;
    }): Promise<any>;
    static consumeToText({ readable }: {
        readable: Readable;
    }): Promise<string>;
    static fromWebReadable({ readableStream, readableOptions }: {
        readableStream: ReadableStream;
        readableOptions?: ReadableStateOptions;
    }): Readable;
    static isDestroyed({ stream }: {
        stream: Readable | Writable | Duplex | Transform;
    }): boolean;
    static isReadable({ readable }: {
        readable: Readable;
    }): boolean;
    static isReadableStream(obj: unknown): obj is Readable;
    static isStream(obj: unknown): obj is Duplex | Readable | Writable | Transform;
    static toWebReadable({ readable }: {
        readable: Readable;
    }): ReadableStream;
}

export { Readable }

// @public
export function removeEmptyObjects(obj: Record<string, unknown>): void;

// @public
export function removeUndefinedProperties(obj: Record<string, unknown>): void;

// @public
export type RequireOnly<T, K extends keyof T, O extends keyof T = never> = Required<Pick<T, K>> & Omit<Partial<T>, O>;

// @public (undocumented)
export class Stream {
    static asAsyncIterator<T>(readableStream: ReadableStream<T>): AsyncIterable<T>;
    static consumeToArrayBuffer({ readableStream }: {
        readableStream: ReadableStream;
    }): Promise<ArrayBuffer>;
    static consumeToBlob({ readableStream }: {
        readableStream: ReadableStream;
    }): Promise<Blob>;
    static consumeToBytes({ readableStream }: {
        readableStream: ReadableStream;
    }): Promise<Uint8Array>;
    static consumeToJson({ readableStream }: {
        readableStream: ReadableStream;
    }): Promise<any>;
    static consumeToText({ readableStream }: {
        readableStream: ReadableStream;
    }): Promise<string>;
    static generateByteStream({ streamLength, chunkLength, fillValue }: {
        streamLength?: number;
        chunkLength?: number;
        fillValue?: number | [number, number];
    }): ReadableStream<Uint8Array>;
    static isReadable({ readableStream }: {
        readableStream: ReadableStream;
    }): boolean;
    static isReadableStream(obj: unknown): obj is ReadableStream;
    static isStream(obj: unknown): obj is ReadableStream | WritableStream | TransformStream;
    static isTransformStream(obj: unknown): obj is TransformStream;
    static isWritableStream(obj: unknown): obj is WritableStream;
}

export { TtlCache }

// @public
export function universalTypeOf(value: unknown): string;

// @public
export type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

// Warnings were encountered during analysis:
//
// src/type-utils.ts:58:5 - (ae-forgotten-export) The symbol "ArrayItems" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```

//#region Crypto Key Stores

/**
 * ManagedKeyStore
 *
 * This interface should be implemented to provide platform specific
 * implementations that are usable by KeyManager and implementations
 * of KeyManagementSystem.
 *
 * Implementations of this class can be used to store:
 *   ManagedKey and ManagedKeyPair
 * or:
 *   ManagedPrivateKey
 * objects.
 *
 * @public
 */
export interface ManagedKeyStore<K, V> {
  deleteKey(options: { id: K }): Promise<boolean>
  getKey(options: { id: K }): Promise<V>
  importKey(options: { key: Omit<V, 'id'> }): Promise<boolean | K>
  listKeys(options: unknown): Promise<V[]>
}

//#endregion Crypto Key Stores


//#region Managed Crypto Keys

export interface BufferKeyPair {
  privateKey: ArrayBuffer;
  publicKey: ArrayBuffer;
}

/** ManagedKey
 *
 * A ManagedKey represents a cryptographic key used by a cipher for
 * encryption or decryption or an algorithm for signing or verification.
 */
export interface ManagedKey {
  /**
   * A unique identifier for the Key, autogenerated by a KMS.
   */
  id: string;

  /**
   * An object detailing the algorithm for which the key can be used along
   * with additional algorithm-specific parameters.
   */
  algorithm: Web5Crypto.KeyGenParams;

  /**
   * An alternate identifier used to identify the key in a KMS.
   * This property can be used to associate a DID document key ID with a ManagedKey.
   */
  alias?: string;


  /**
   * A boolean value that is `true` if the key can be exported and `false` if not.
   */
  extractable: boolean;

  /**
   * Name of a registered key management system.
   */
  kms: string;

  /**
   * Optional. Key material as a raw binary data buffer.
   */
  material?: ArrayBuffer;

  /**
   * Optional. Additional Key metadata.
   */
  metadata?: KeyMetadata;

  /**
   * A registered string value specifying the algorithm and any algorithm
   * specific parameters.
   * Supported algorithms vary by KMS.
   */
  spec?: string;

  /**
   * The current status of the ManagedKey.
   */
  state: KeyState;

  /**
   * The type of key.
   */
  type: KeyType;

  /**
   * Indicates which cryptographic operations are permissible to be used with this key.
   */
  usages: KeyUsage[];
}

/**
 * Represents information about a managed key.
 * Private or secret key material is NOT present.
 *
 */
export type ManagedKeyInfo = Omit<ManagedKey, 'material'>;

/** ManagedKeyPair
 *
 * A ManagedKeyPair represents a key pair for an asymmetric cryptography algorithm,
 * also known as a public-key algorithm.
 *
 * A ManagedKeyPair object can be obtained using `generateKey()`, when the
 * selected algorithm is one of the asymmetric algorithms: ECDSA or ECDH.
 */
export interface ManagedKeyPair {
  /**
   * A ManagedKey object representing the private key. For encryption and
   * decryption algorithms, this key is used to decrypt. For signing and
   * verification algorithms it is used to sign.
   */
  privateKey: ManagedKey;

  /**
   * A ManagedKey object representing the public key. For encryption and
   * decryption algorithms, this key is used to encrypt. For signing and
   * verification algorithms it is used to verify signatures.
   */
  publicKey: ManagedKey;
}

/**
 * Represents a private key.
 *
 * The `alias` is used to refer to the key material which is stored as the hex encoding of the raw byte array
 * (`privateKeyHex`).
 *
 * The `type` refers to the type of key that is represented.
 *
 * @public
 */
export interface ManagedPrivateKey {
  /**
   * A unique identifier for the Key, autogenerated by a KMS.
   */
  id: string

  /**
   * Key material as a raw binary data buffer.
   */
  material: ArrayBuffer;

  /**
   * The type of key.
   */
  type: Web5Crypto.PrivateKeyType;
}

/**
 * KeyState
 *
 * The read-only `state` property of the `ManagedKey` interface indicates the
 * status of the ManagedKey.
 *
 * It can have the following string values:
 *
 *   "Enabled": The key is ready for use.
 *
 *   "Disabled": The key may not be used, but the key material is still available,
 *               and the key can be placed back into the Enabled state.
 *
 *   "PendingCreation": The key is still being created. It may not be used,
 *                      enabled, disabled, or destroyed yet.  The KMS will
 *                      automatically change the state to enabled as soon
 *                      as the key is ready.
 *
 *   "PendingDeletion": The key is scheduled for deletion. It can be placed back
 *                      into the Disabled state up until the time of deletion
 *                      using the CancelKeyDeletion() method. Once the key has
 *                      been deleted, any ciphertext encrypted with this key
 *                      is no longer recoverable. Minimum and maximum waiting
 *                      periods are defined by each KMS implementation.
 *
 *   "PendingImport": The key is still being imported. It may not be used, enabled,
 *                    disabled, or deleted yet. The KMS will automatically change
 *                    the state to Enabled once the key is ready.
 *
 *   "PendingUpdate": The key is still being updated. It may not be used, enabled,
 *                    disabled, or deleted until the update process completes.
 *                    The KMS will automatically change the state to Enabled
 *                    once the key is ready.
 */
export type KeyState = 'Enabled' | 'Disabled' | 'PendingCreation' | 'PendingDeletion' | 'PendingImport' | 'PendingUpdate';

/**
 * KeyMetadata
 *
 * Implementations of KeyManagementSystem can populate this object with KMS platform
 * specific data about each key.
 *
 * This property can also be used to add various tags to the keys under management.
 */
export type KeyMetadata = {
  /**
   * Additional properties of any type.
   */
  [key: string]: any;
}

//#endregion Managed Crypto Keys


//#region Key Management Systems

/**
 * Base interface to be implemented by key management systems.
 */
export interface KeyManagementSystem extends CryptoManager {
  /**
   * Create a new ManagedKey within a KMS.
   */
  temp?(options: any): Promise<ManagedKey | ManagedKeyPair>;

  /**
   * Schedule a ManagedKey for deletion.
   * Upon calling this method,
   *
   * @param {string} id
   *   The id property of the key to delete.
   * @param {object} [options]
   *   Optional. Additional deletion options specified by the KMS implementation.
   */
  // deleteKey(id: string, options?: { [key: string]: unknown }): Promise<DeleteKeyResponse>

  /**
   * Provides detailed information about a key.
   *
   * @param {string} keyRef
   *   An identifier of the ManagedKey to get.
   *   You can use the id or alias property of the key.
   */
  // getKey(keyRef: Pick<ManagedKey, 'id' | 'alias'>): Promise<ManagedKey>

  /**
   * Get the public key for the given ManagedKey.
   * Only valid for asymmetric keys.
   *
   * @param {string} keyRef
   *   An identifier of the ManagedKey to get.
   *   You can use the id or alias property of the key.
   */
  // getPublicKey(keyRef: Pick<ManagedKey, 'id' | 'alias'>): Promise<ManagedKey>

  /**
   * Takes as input key material and imports into the KMS as `ManagedKey`.
   */
  // importKey(keyMaterial: ArrayBuffer, options: ImportKeyOptions): Promise<ManagedKey>

  /**
   * List all ManagedKeys present in the KMS.
   */
  // listKeys(): Promise<ListKeysResponse[]>
}

export type DeleteKeyResponse = Pick<ManagedKey, 'id' | 'state'> & {
  /**
   * The date and time after which the KMS deletes the ManagedKey.
   */
  deletionDate: Date;
}

export type ImportKeyOptions = Omit<ManagedKey, 'id' | 'kms'>;

export type ListKeysResponse = Pick<ManagedKey, 'id' | 'alias'>;

//#endregion Key Management Systems

//#region Web5 Crypto namespace

export namespace Web5Crypto {
  export interface AesGenerateKeyOptions extends Algorithm {
    length: number;
  }

  export interface Algorithm {
    name: string;
  }

  export type AlgorithmIdentifier = Algorithm;

  export interface CryptoKey {
    algorithm: KeyGenParams;
    extractable: boolean;
    handle: ArrayBuffer;
    type: KeyType;
    usages: KeyUsage[];
  }

  export interface CryptoKeyPair {
    privateKey: CryptoKey;
    publicKey: CryptoKey;
  }

  export interface EcdsaOptions extends Algorithm {
    hash: string;
  }

  export interface EcGenerateKeyOptions extends Algorithm {
    namedCurve: NamedCurve;
  }

  export interface EcdhDeriveKeyOptions {
    publicKey: CryptoKey;
  }

  export interface EcdsaGenerateKeyOptions extends EcGenerateKeyOptions {
    compressedPublicKey?: boolean;
  }

  export type EdDsaGenerateKeyOptions = EcGenerateKeyOptions

  export interface EdDsaOptions extends Algorithm {
    hash: string;
  }

  export interface KeyAlgorithm {
    name: string;
  }

  export type KeyGenParams = AesGenerateKeyOptions | EcGenerateKeyOptions;

  /**
   * KeyType
   *
   * The read-only `type` property of the `ManagedKey` interface indicates which
   * kind of key is represented by the object.
   *
   * It can have the following string values:
   *
   *   "secret": This key is a secret key for use with a symmetric algorithm.
   *   "private": This key is the private half of an asymmetric algorithm's `ManagedKeyPair`.
   *   "public": This key is the public half of an asymmetric algorithm's `ManagedKeyPair`.
   */
  export type KeyType = 'private' | 'public' | 'secret';

  export type PrivateKeyType = 'private' | 'secret';

  /**
   * KeyUsage
   *
   * The read-only usage property of the CryptoKey interface indicates what can be
   * done with the key.
   *
   * An Array of strings from the following list:
   *
   *   "encrypt": The key may be used to encrypt messages.
   *   "decrypt": The key may be used to decrypt messages.
   *   "sign": The key may be used to sign messages.
   *   "verify": The key may be used to verify signatures.
   *   "deriveKey": The key may be used in deriving a new key.
   *   "deriveBits": The key may be used in deriving bits.
   *   "wrapKey": The key may be used to wrap a key.
   *   "unwrapKey": The key may be used to unwrap a key.
   *
   * Reference: IANA "JSON Web Key Operations" registry
   *            https://www.iana.org/assignments/jose/jose.xhtml#web-key-operations
   */
  export type KeyUsage = 'encrypt' | 'decrypt' | 'sign' | 'verify' | 'deriveKey' | 'deriveBits' | 'wrapKey' | 'unwrapKey';

  export interface KeyPairUsage {
    privateKey: KeyUsage[];
    publicKey: KeyUsage[];
  }

  export type NamedCurve = string;
}

//#endregion Web5 Crypto namespace



export interface CryptoManager {
  // decrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>;

  // deriveBits(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, length: number): Promise<ArrayBuffer>;

  // deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;

  // digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;

  // encrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>;

  // exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>;
  // exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>;

  // generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>;
  // generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;
  // generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair | CryptoKey>;

  // importKey(format: "jwk", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;
  // importKey(format: Exclude<KeyFormat, "jwk">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;

  // sign(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>;

  // unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey>;

  // verify(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<boolean>;

  // wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<ArrayBuffer>;

  /**
   * Generate a new ManagedKey within a CryptoManager implementation.
   */
  generateKey<T extends GenerateKeyOptionTypes>(options: GenerateKeyOptions<T>): Promise<GenerateKeyType<T>>;

  /**
   * Retrieves detailed information about a ManagedKey or ManagedKeyPair object.
   *
   * @param options - The options for retrieving the key.
   * @param options.keyRef - The reference identifier for the key. Can specify the id or alias property of the key.
   * @returns A promise that resolves to either a ManagedKey or ManagedKeyPair object.
   */
  getKey(options: { keyRef: string }): Promise<ManagedKey | ManagedKeyPair>;

  sign(options: SignOptions): Promise<ArrayBuffer>;
}

export type GenerateKeyOptionTypes =
  | Web5Crypto.AlgorithmIdentifier
  | RsaHashedKeyGenParams
  | Web5Crypto.EcdsaGenerateKeyOptions
  | Web5Crypto.EdDsaGenerateKeyOptions
  | Web5Crypto.AesGenerateKeyOptions
  | HmacKeyGenParams
  | Pbkdf2Params;

export type GenerateKeyOptions<T extends GenerateKeyOptionTypes> = {
  algorithm: T;
  alias?: string;
  extractable?: boolean;
  keyUsages: Web5Crypto.KeyUsage[];
  metadata?: KeyMetadata;
};

export type GenerateKeyType<T> = T extends Web5Crypto.EcGenerateKeyOptions ? ManagedKeyPair :
  T extends Web5Crypto.AesGenerateKeyOptions | HmacKeyGenParams | Pbkdf2Params ? ManagedKey :
  T extends Web5Crypto.AlgorithmIdentifier ? ManagedKey | ManagedKeyPair :
  never;

/**
 * Input arguments for implementations of the CryptoManager interface {@link CryptoManager.sign | sign} method.
 *
 * @public
 */
export type SignOptions = {
  /**
   * An object that specifies the signature algorithm to use and its parameters.
   */
  algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.EcdsaOptions | Web5Crypto.EdDsaOptions;

  /**
   * An ArrayBuffer, a TypedArray, or a DataView object containing the data to be signed.
   */
  data: BufferSource;

  /**
   * A CryptoKey object containing the key to be used for signing.
   * If signing algorithm is a public-key cryptosystem, this is the private key.
   */
  key?: ManagedKey;

  /**
   *   An identifier of the ManagedKey to sign with.
   *   You can use the id or alias property of the key.
   */
  keyRef?: string;
}
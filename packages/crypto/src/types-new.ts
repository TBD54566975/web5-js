//#region Crypto Key Stores

/**
 * ManagedKeyStore
 *
 * This interface should be implemented to provide platform specific
 * implementations that are usable by KeyManager and implementations
 * of KeyManagementSystem.
 *
 * Implementations of this class can be used to store:
 *   ManagedKey and ManagedKeyPair
 * or:
 *   ManagedPrivateKey
 * objects.
 *
 * @public
 */
export interface CryptoKeyStore<K, V> {
  deleteKey(options: { id: K }): Promise<boolean>
  getKey(options: { id: K }): Promise<V>
  importKey(options: { key: Omit<V, 'id'> }): Promise<boolean | K>
  listKeys(options: unknown): Promise<V[]>
}

//#endregion Crypto Key Stores


//#region Managed Crypto Keys

/** ManagedKey
 *
 * A ManagedKey represents a cryptographic key used by a cipher for
 * encryption or decryption or an algorithm for signing or verification.
 */
export interface ManagedKey {
  /**
   * A unique identifier for the Key, autogenerated by a KMS.
   */
  id: string;

  /**
   * An object detailing the algorithm for which the key can be used along
   * with additional algorithm-specific parameters.
   */
  algorithm: Web5Crypto.KeyGenParams;

  /**
   * An alternate identifier used to identify the key in a KMS.
   * This property can be used to associate a DID document key ID with a ManagedKey.
   */
  alias?: string;


  /**
   * A boolean value that is `true` if the key can be exported and `false` if not.
   */
  extractable?: boolean;

  /**
   * Name of a registered key management system.
   */
  kms?: string;

  /**
   * Optional. Key material as a raw binary data buffer.
   */
  material?: ArrayBuffer;

  /**
   * Optional. Additional Key metadata.
   */
  metadata?: KeyMetadata | undefined;

  /**
   * A registered string value specifying the algorithm and any algorithm
   * specific parameters.
   * Supported algorithms vary by KMS.
   */
  spec: string;

  /**
   * The current status of the ManagedKey.
   */
  state: KeyState;

  /**
   * The type of key.
   */
  type: KeyType;

  /**
   * Indicates which cryptographic operations are permissible to be used with this key.
   */
  usages: KeyUsage[];
}

/**
 * Represents information about a managed key.
 * Private or secret key material is NOT present.
 *
 */
export type ManagedKeyInfo = Omit<ManagedKey, 'material'>;

/** ManagedKeyPair
 *
 * A ManagedKeyPair represents a key pair for an asymmetric cryptography algorithm,
 * also known as a public-key algorithm.
 *
 * A ManagedKeyPair object can be obtained using `createKey()`, when the
 * selected algorithm is one of the asymmetric algorithms: ECDSA or ECDH.
 */
export interface ManagedKeyPair {
  /**
   * A ManagedKey object representing the private key. For encryption and
   * decryption algorithms, this key is used to decrypt. For signing and
   * verification algorithms it is used to sign.
   */
  privateKey?: ManagedKey;

  /**
   * A ManagedKey object representing the public key. For encryption and
   * decryption algorithms, this key is used to encrypt. For signing and
   * verification algorithms it is used to verify signatures.
   */
  publicKey?: ManagedKey;
}

/**
 * Represents a private key.
 *
 * The `alias` is used to refer to the key material which is stored as the hex encoding of the raw byte array
 * (`privateKeyHex`).
 *
 * The `type` refers to the type of key that is represented.
 *
 * @public
 */
export interface ManagedPrivateKey {
  /**
   * A unique identifier for the Key, autogenerated by a KMS.
   */
  id: string

  /**
   * Key material as a raw binary data buffer.
   */
  material: ArrayBuffer;

  /**
   * The type of key.
   */
  type: Web5Crypto.PrivateKeyType;
}

/**
 * KeyState
 *
 * The read-only `state` property of the `ManagedKey` interface indicates the
 * status of the ManagedKey.
 *
 * It can have the following string values:
 *
 *   "Enabled": The key is ready for use.
 *
 *   "Disabled": The key may not be used, but the key material is still available,
 *               and the key can be placed back into the Enabled state.
 *
 *   "PendingCreation": The key is still being created. It may not be used,
 *                      enabled, disabled, or destroyed yet.  The KMS will
 *                      automatically change the state to enabled as soon
 *                      as the key is ready.
 *
 *   "PendingDeletion": The key is scheduled for deletion. It can be placed back
 *                      into the Disabled state up until the time of deletion
 *                      using the CancelKeyDeletion() method. Once the key has
 *                      been deleted, any ciphertext encrypted with this key
 *                      is no longer recoverable. Minimum and maximum waiting
 *                      periods are defined by each KMS implementation.
 *
 *   "PendingImport": The key is still being imported. It may not be used, enabled,
 *                    disabled, or deleted yet. The KMS will automatically change
 *                    the state to Enabled once the key is ready.
 *
 *   "PendingUpdate": The key is still being updated. It may not be used, enabled,
 *                    disabled, or deleted until the update process completes.
 *                    The KMS will automatically change the state to Enabled
 *                    once the key is ready.
 */
export type KeyState = 'Enabled' | 'Disabled' | 'PendingCreation' | 'PendingDeletion' | 'PendingImport' | 'PendingUpdate';

/**
 * KeyMetadata
 *
 * Implementations of KeyManagementSystem can populate this object with KMS platform
 * specific data about each key.
 *
 * This property can also be used to add various tags to the keys under management.
 */
export type KeyMetadata = {
  /**
   * Additional properties of any type.
   */
  [key: string]: any;
}

//#endregion Managed Crypto Keys


//#region Key Management Systems

/**
 * Base interface to be implemented by key management systems.
 */
export interface KeyManagementSystem {
  /**
   * Create a new ManagedKey within a KMS.
   */
  createKey(options: CreateKeyOptions): Promise<ManagedKey | ManagedKeyPair>;

  /**
   * Schedule a ManagedKey for deletion.
   * Upon calling this method,
   *
   * @param {string} id
   *   The id property of the key to delete.
   * @param {object} [options]
   *   Optional. Additional deletion options specified by the KMS implementation.
   */
  // deleteKey(id: string, options?: { [key: string]: unknown }): Promise<DeleteKeyResponse>

  /**
   * Provides detailed information about a key.
   *
   * @param {string} keyRef
   *   An identifier of the ManagedKey to get.
   *   You can use the id or alias property of the key.
   */
  // getKey(keyRef: Pick<ManagedKey, 'id' | 'alias'>): Promise<ManagedKey>

  /**
   * Get the public key for the given ManagedKey.
   * Only valid for asymmetric keys.
   *
   * @param {string} keyRef
   *   An identifier of the ManagedKey to get.
   *   You can use the id or alias property of the key.
   */
  // getPublicKey(keyRef: Pick<ManagedKey, 'id' | 'alias'>): Promise<ManagedKey>

  /**
   * Takes as input key material and imports into the KMS as `ManagedKey`.
   */
  // importKey(keyMaterial: ArrayBuffer, options: ImportKeyOptions): Promise<ManagedKey>

  /**
   * List all ManagedKeys present in the KMS.
   */
  // listKeys(): Promise<ListKeysResponse[]>
}

export type CreateKeyOptions = {
  additionalOptions?: { [key: string]: any };
  extractable: boolean;
  spec: string;
  usages: Web5Crypto.KeyUsage[];
}

export type DeleteKeyResponse = Pick<ManagedKey, 'id' | 'state'> & {
  /**
   * The date and time after which the KMS deletes the ManagedKey.
   */
  deletionDate: Date;
}

export type ImportKeyOptions = Omit<ManagedKey, 'id' | 'kms'>;

export type ListKeysResponse = Pick<ManagedKey, 'id' | 'alias'>;

//#endregion Key Management Systems

//#region Web5 Crypto namespace

export namespace Web5Crypto {
  export interface AesKeyGenParams extends Algorithm {
    length: number;
  }

  export interface Algorithm {
    name: string;
  }

  export interface CryptoKey {
    algorithm: KeyGenParams;
    extractable: boolean;
    handle: ArrayBuffer;
    type: KeyType;
    usages: KeyUsage[];
  }

  export interface CryptoKeyPair {
    privateKey: CryptoKey;
    publicKey: CryptoKey;
  }

  export interface KeyAlgorithm {
    name: string;
  }

  export interface EcdsaParams extends Algorithm {
    hash: string;
  }

  export interface EdDsaParams extends Algorithm {
    hash: string;
  }

  export interface EcKeyGenParams extends Algorithm {
    namedCurve: NamedCurve;
  }

  export type KeyGenParams = AesKeyGenParams | EcKeyGenParams;

  /**
   * KeyType
   *
   * The read-only `type` property of the `ManagedKey` interface indicates which
   * kind of key is represented by the object.
   *
   * It can have the following string values:
   *
   *   "secret": This key is a secret key for use with a symmetric algorithm.
   *   "private": This key is the private half of an asymmetric algorithm's `ManagedKeyPair`.
   *   "public": This key is the public half of an asymmetric algorithm's `ManagedKeyPair`.
   */
  export type KeyType = 'private' | 'public' | 'secret';

  export type PrivateKeyType = 'private' | 'secret';

  /**
   * KeyUsage
   *
   * The read-only usage property of the CryptoKey interface indicates what can be
   * done with the key.
   *
   * An Array of strings from the following list:
   *
   *   "encrypt": The key may be used to encrypt messages.
   *   "decrypt": The key may be used to decrypt messages.
   *   "sign": The key may be used to sign messages.
   *   "verify": The key may be used to verify signatures.
   *   "deriveKey": The key may be used in deriving a new key.
   *   "deriveBits": The key may be used in deriving bits.
   *   "wrapKey": The key may be used to wrap a key.
   *   "unwrapKey": The key may be used to unwrap a key.
   *
   * Reference: IANA "JSON Web Key Operations" registry
   *            https://www.iana.org/assignments/jose/jose.xhtml#web-key-operations
   */
  export type KeyUsage = 'encrypt' | 'decrypt' | 'sign' | 'verify' | 'deriveKey' | 'deriveBits' | 'wrapKey' | 'unwrapKey';

  export interface KeyPairUsage {
    privateKey: KeyUsage[];
    publicKey: KeyUsage[];
  }

  export type NamedCurve = string;
}

//#endregion Web5 Crypto namespace